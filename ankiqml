#!/usr/bin/python2.6

import sys, os
sys.path[0] = "/usr/share/ankiqml"

from PySide import QtCore
from PySide.QtGui import *
from PySide.QtCore import *
from PySide.QtDeclarative import QDeclarativeView
import anki

class DecksModel(QAbstractListModel):

    NameRole = Qt.UserRole + 1
    PathRole = Qt.UserRole + 2
    FactCountRole = Qt.UserRole + 3

    def __init__(self, parent = None):
        QAbstractListModel.__init__(self, parent)
        self.setRoleNames({
            DecksModel.NameRole : 'deckName',
            DecksModel.PathRole : 'deckPath',
            DecksModel.FactCountRole : 'deckFactCount',
            Qt.DisplayRole : 'display' 
            })
        self._data = []

    @QtCore.Slot(result=int)
    def getCount(self):
        return len(self._data)

    def rowCount(self, index):
        return len(self._data)

    @QtCore.Slot(int, str, str)
    def setData(self, index, role, value):
        self._data[index][role] = value
        self.emit(QtCore.SIGNAL("dataChanged()"))

    @QtCore.Slot(int, str, result=str)
    def getData(self, index, role):
        d = self._data[index]
        return d[role]

    def data(self, index, role):
        d = self._data[index.row()]

        if role == Qt.DisplayRole:
            return d['name']
        elif role == Qt.DecorationRole:
            return Qt.black
        elif role == DecksModel.NameRole:
            return d['deckName']
        elif role == DecksModel.PathRole:
            return d['deckPath']
        elif role == DecksModel.FactCountRole:
            return d['deckFactCount']
        return None

    def populate(self):
        path="/home/user/devel/decks"
        if not os.path.isdir(path):
            os.mkdir(path)
        dirList=os.listdir(path)
        for fname in dirList:
            if fname.endswith(".anki"):
                print fname
                self._data.append({'name':fname, 'deckName': fname, 'deckPath':path+'/'+fname, 'deckFactCount': 100})

class DeckWrapper(QtCore.QObject):

    def __init__(self, parent = None):
        QtCore.QObject.__init__(self, parent)
        self.opened = False
        self.finished = False

    def __del__(self, parent = None):
        self.stopSession()
        self.closeDeck()

    @QtCore.Slot(str)
    def openDeck(self, s):
        self.deck = anki.DeckStorage.Deck(s, backup=False)
        self.opened = True

    @QtCore.Slot()
    def closeDeck(self):
        self.deck.save()
        self.deck.s.flush()
        self.deck.close()
        self.opened = False

    @QtCore.Slot()
    def startSession(self):
        self.deck.startSession()
        
    @QtCore.Slot()
    def stopSession(self):
        self.deck.stopSession()
        self.finished = False

    @QtCore.Slot()
    def getCard(self):
        if not self.opened:
            return
        self.card = self.deck.getCard()
        if not self.card:
            self.finished = True

    @QtCore.Slot(result=str)
    def getQuestion(self):
        if not self.opened:
            return ""
        return self.card.htmlQuestion()

    @QtCore.Slot(result=str)
    def getAnswer(self):
        if not self.opened:
            return ""
        return self.card.htmlAnswer()

    @QtCore.Slot(int)
    def answerCard(self, quality):
        if not self.opened:
            return
        self.deck.s.refresh(self.card)
        self.deck.s.refresh(self.card.fact)
        self.deck.s.refresh(self.card.cardModel)
        self.deck.s.expunge(self.card)

        self.deck.answerCard(self.card, quality)

    @QtCore.Slot(result=bool)
    def Finished(self):
        return self.finished

    @QtCore.Slot(result=str)
    def DeckFinishedMsg(self):
        if self.finished:
            return self.deck.deckFinishedMsg()

    @QtCore.Slot(str, result=str)
    def getDeckInfo(self, key):
        if self.opened == False:
            return ""
        self.deckInfo = {
            "name": self.deck.name(),
            "description": `self.deck.description`,
            "cardCount": `self.deck.cardCount`,
            "factCount": `self.deck.factCount`,
            "revCount": `self.deck.revCount`,
            "newCount": `self.deck.newCount`,
        }
        return self.deckInfo.get(key, "")

    @QtCore.Slot(result="QVariantList")
    def CurrentModelFields(self):
        fields = []
        model = self.deck.currentModel
        for fieldModel in model.fieldModels:
            fields.append(fieldModel.name)
        return fields

    def _updateFact(self, fact, map):
        for i in range(0, len(map.keys())):
            fact.__setitem__(map.keys()[i], map.values()[i])
        if self.deck.factIsInvalid(fact):
            return False
        return True

    @QtCore.Slot("QVariantMap", result=bool)
    def AddFact(self, map):
        if self.opened == False:
            return False

        fact = self.deck.newFact()
        self._updateFact(fact, map)
        self.deck.addFact(fact)
        self._reset()

        return True

    @QtCore.Slot(str, result=str)
    def getFactInfo(self, key):
        if self.opened == False:
            return ""
        self.factInfo = {
            "id": `self.card.fact.id`,
        }
        return self.factInfo.get(key, "")

    @QtCore.Slot(str, result=str)
    def getFactValue(self, key):
        if self.opened == False:
            return ""
        return self.card.fact.__getitem__(key)

    @QtCore.Slot("QVariantMap", result=bool)
    def EditFact(self, map):
        if self.opened == False:
            return False

        fact = self.card.fact
        self._updateFact(fact, map)
        fact.setModified(textChanged=True, deck=self.deck)
        self.deck.save()
        self.deck.s.refresh(fact)
        self._reset()

        return True

    def _reset(self):
        if self.opened == False:
            return False
        self.deck.refreshSession()
        self.deck.reset()

    @QtCore.Slot(result=bool)
    def deleteCurrentCard(self):
        if self.opened == False:
            return False
        self.deck.deleteCard(self.card.id)
        self._reset()
        return True

    @QtCore.Slot()
    def initCramming(self):
        self.deck.setupCramScheduler("", "random()")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    view = QDeclarativeView()
    url = QUrl('/usr/share/ankiqml/qml/view.qml')

    decksModel = DecksModel()
    decksModel.populate()
    deck = DeckWrapper()

    ctx = view.rootContext()
    ctx.setContextProperty('Deck', deck)
    ctx.setContextProperty('decksModel', decksModel)

    view.setResizeMode(QDeclarativeView.SizeRootObjectToView)
    view.setSource(url)
    view.showFullScreen()
    sys.exit(app.exec_())
